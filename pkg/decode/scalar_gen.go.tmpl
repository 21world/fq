// Code below generated from scalar_gen.go.tmpl
package decode

import (
	"errors"
	"fmt"

	"github.com/wader/fq/pkg/bitio"
)

{{- range $name, $t := $.types }}
	// Type {{$name}}

	// Actual{{$name}} asserts actual value is a {{$name}} and returns it
	func (s Scalar) Actual{{$name}}() {{$t.go_type}} {
		v, ok := s.Actual.({{$t.go_type}})
		if !ok {
			panic(fmt.Sprintf("failed to type assert s.Actual %v as {{$t.go_type}}", s.Actual))
		}
		return v
	}

	// Sym{{$name}} asserts symbolic value is a {{$name}} and returns it
	func (s Scalar) Sym{{$name}}() {{$t.go_type}} {
		v, ok := s.Sym.({{$t.go_type}})
		if !ok {
			panic(fmt.Sprintf("failed to type assert s.Sym %v as {{$t.go_type}}", s.Sym))
		}
		return v
	}

	// TryField{{$name}}ScalarFn tries to add a field, calls scalar functions and returns actual value as a {{$name}}
	func (d *D) TryField{{$name}}ScalarFn(name string, fn func(d *D) (Scalar, error), sfns ...ScalarFn) ({{$t.go_type}}, error) {
		v, err := d.TryFieldScalar(name, func(_ Scalar) (Scalar, error) { return fn(d) }, sfns...)
		if err != nil {
			return {{$t.zero}}, err
		}
		return v.Actual{{$name}}(), err
	}

	// Field{{$name}}ScalarFn adds a field, calls scalar functions and returns actual value as a {{$name}}
	func (d *D) Field{{$name}}ScalarFn(name string, fn func(d *D) Scalar, sfns ...ScalarFn) {{$t.go_type}} {
		v, err := d.TryFieldScalar(name, func(_ Scalar) (Scalar, error) { return fn(d), nil }, sfns...)
		if err != nil {
			panic(IOError{Err: err, Name: name, Op: "{{$name}}", Pos: d.Pos()})
		}
		return v.Actual{{$name}}()
	}

	// Field{{$name}}Fn adds a field, calls {{$t.go_type}} decode function and returns actual value as a {{$name}}
	func (d *D) Field{{$name}}Fn(name string, fn func(d *D) {{$t.go_type}}, sfns ...ScalarFn) {{$t.go_type}} {
		return d.Field{{$name}}ScalarFn(name, func(d *D) Scalar { return Scalar{Actual: fn(d) } }, sfns...)
	}

	// TryField{{$name}}Fn tries to add a field, calls {{$t.go_type}} decode function and returns actual value as a {{$name}}
	func (d *D) TryField{{$name}}Fn(name string, fn func(d *D) ({{$t.go_type}}, error), sfns ...ScalarFn) ({{$t.go_type}}, error) {
		return d.TryField{{$name}}ScalarFn(name, func(d *D) (Scalar, error) {
			v, err := fn(d)
			return Scalar{Actual: v}, err
		}, sfns...)
	}

	// TryFieldScalar{{$name}}Fn tries to add a field, calls {{$t.go_type}} decode function and returns scalar
	func (d *D) TryFieldScalar{{$name}}Fn(name string, fn func(d *D) ({{$t.go_type}}, error), sfns ...ScalarFn) (Scalar, error) {
		return d.TryFieldScalar(name, func(_ Scalar) (Scalar, error) {
			v, err := fn(d)
			return Scalar{Actual: v}, err
		}, sfns...)
	}

	// FieldScalar{{$name}}Fn tries to add a field, calls {{$t.go_type}} decode function and returns scalar
	func (d *D) FieldScalar{{$name}}Fn(name string, fn func(d *D) {{$t.go_type}}, sfns ...ScalarFn) Scalar {
		v, err := d.TryFieldScalar{{$name}}Fn(name, func(d *D) ({{$t.go_type}}, error) { return fn(d), nil }, sfns...)
		if err != nil {
			panic(IOError{Err: err, Name: name, Op: "{{$name}}", Pos: d.Pos()})
		}
		return v
	}
{{end}}

{{- range $name, $t := $.types }}
	{{- if $t.compare}}
		// Validate/Assert {{$name}}

		func (d *D) assert{{$name}}(assert bool, vs ...{{$t.go_type}}) func(s Scalar) (Scalar, error) {
			return func(s Scalar) (Scalar, error) {
				a := s.Actual{{$name}}()
				for _, b := range vs {
					if {{$t.compare}} {
						s.Description = "valid"
						return s, nil
					}
				}
				s.Description = "invalid"
				if assert && !d.Options.Force {
					return s, errors.New("failed to assert {{$name}}")
				}
				return s, nil
			}
		}

		// Assert{{$name}} asserts that actual value is one of given {{$t.go_type}} values
		func (d *D) Assert{{$name}}(vs ...{{$t.go_type}}) func(s Scalar) (Scalar, error) {
			return d.assert{{$name}}(true, vs...)
		}
		// Validate{{$name}} validates that actual value is one of given {{$t.go_type}} values
		func (d *D) Validate{{$name}}(vs ...{{$t.go_type}}) func(s Scalar) (Scalar, error) {
			return d.assert{{$name}}(false, vs...)
		}
	{{- end}}
{{- end}}

{{- range $from_name, $from := $.types }}
	{{- if ne $from.map_from false}}
		// Map {{$from_name}} -> Scalar

		type {{$from_name}}ToScalar map[{{$from.go_type}}]Scalar

		// Map{{$from_name}}ToScalar maps {{$from_name}} to a Scalar
		func (d *D) Map{{$from_name}}ToScalar(m {{$from_name}}ToScalar) func(s Scalar) (Scalar, error) {
			return func(s Scalar) (Scalar, error) {
				a := s.Actual{{$from_name}}()
				if ns, ok := m[a]; ok {
					ns.Actual = a
					s = ns
				}
				return s, nil
			}
		}

		{{- range $to_name, $to := $.types }}
			{{- if ne $to.map_to false}}
				// Map {{$from_name}} -> {{$to_name}}

				type {{$from_name}}To{{$to_name}} map[{{$from.go_type}}]{{$to.go_type}}

				// Map{{$from_name}}To{{$to_name}}Sym maps {{$from_name}} to a symolic {{$to_name}}
				func (d *D) Map{{$from_name}}To{{$to_name}}Sym(m {{$from_name}}To{{$to_name}}) func(s Scalar) (Scalar, error) {
					return func(s Scalar) (Scalar, error) {
						if t, ok := m[s.Actual{{$from_name}}()]; ok {
							s.Sym = t
						}
						return s, nil
					}
				}
			{{- end}}
		{{- end}}
	{{- end}}
{{- end}}

{{- range $r := $.readers }}
	{{- $t := index $.types $r.type }}

	{{- range $v := $r.variants }}
		{{- $range_start := 1 }}
		{{- $range_stop := 1 }}
		{{- if $v.range }}
			{{- $range_start = index $v.range 0 }}
			{{- $range_stop = index $v.range 1 }}
		{{- end}}

		{{- range $n := xrange $range_start $range_stop }}

			// Reader {{$r.name}}{{replace $v.name "$n" $n}}

			// Try{{$r.name}}{{replace $v.name "$n" $n}} tries to read {{replace $v.doc "$n" $n}}
			func (d *D) Try{{$r.name}}{{replace $v.name "$n" $n}}({{$v.params}}) ({{$t.go_type}}, error) { return {{replace $v.call "$n" $n}} }

			// {{$r.name}}{{replace $v.name "$n" $n}} reads {{replace $v.doc "$n" $n}}
			func (d *D) {{$r.name}}{{replace $v.name "$n" $n}}({{$v.params}}) {{$t.go_type}} {
				v, err := {{replace $v.call "$n" $n}}
				if err != nil {
					panic(IOError{Err: err, Op: "{{$r.name}}{{replace $v.name "$n" $n}}", Pos: d.Pos()})
				}
				return v
			}

			// TryField{{$r.name}}{{replace $v.name "$n" $n}} tries to add a field and read {{replace $v.doc "$n" $n}}
			func (d *D) TryField{{$r.name}}{{replace $v.name "$n" $n}}(name string{{if $v.params}}, {{$v.params}}{{end}}, sfns ...ScalarFn) ({{$t.go_type}}, error) {
				{{- if $v.params}}
					v, err := d.TryFieldScalar(name, func(s Scalar) (Scalar, error) {
						v, err := {{replace $v.call "$n" $n}}
						s.Actual = v
						return s, err
					}, sfns...)
					if err != nil {
						return {{$t.zero}}, err
					}
					return v.Actual{{$r.type}}(), err
				{{- else}}
					return d.TryField{{$r.type}}Fn(name, (*D).Try{{$r.name}}{{replace $v.name "$n" $n}}, sfns...)
				{{- end}}
			}

			// Field{{$r.name}}{{replace $v.name "$n" $n}} adds a field and reads {{replace $v.doc "$n" $n}}
			func (d *D) Field{{$r.name}}{{replace $v.name "$n" $n}}(name string{{if $v.params}}, {{$v.params}}{{end}}, sfns ...ScalarFn) {{$t.go_type}} {
				{{- if $v.params}}
					v, err := d.TryField{{$r.name}}{{replace $v.name "$n" $n}}(name{{if $v.args}}, {{$v.args}}{{end}}, sfns...)
					if err != nil {
						panic(IOError{Err: err, Name: name, Op: "{{$r.name}}{{replace $v.name "$n" $n}}", Pos: d.Pos()})
					}
					return v
				{{- else}}
					return d.Field{{$r.type}}Fn(name, (*D).{{$r.name}}{{replace $v.name "$n" $n}}, sfns...)
				{{- end}}
			}
		{{- end}}
	{{- end}}
{{- end}}
